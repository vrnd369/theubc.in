import React, { useState, useEffect } from 'react';
import ImageSelector from '../ImageSelector/ImageSelector';
import './NavigationEditor.css';

export default function NavigationEditor({ item, onSave, onCancel }) {
  const [formData, setFormData] = useState({
    label: '',
    path: '',
    type: 'link',
    order: 0,
    items: []
  });

  const [errors, setErrors] = useState({});
  const [originalItem, setOriginalItem] = useState(null); // Store original item for reference

  useEffect(() => {
    if (item) {
      setOriginalItem(item); // Store the original item
      setFormData({
        label: item.label || '',
        path: item.path || '',
        type: item.type || 'link',
        order: item.order || 0,
        items: item.items ? [...item.items] : [],
        id: item.id || '',
        autoGenerated: item.autoGenerated || false,
        firestoreId: item.firestoreId || item.id || ''
      });
    } else {
      setOriginalItem(null);
      // Set default order for new items (within max limit of 7)
      setFormData(prev => ({
        ...prev,
        order: 7 // Default to maximum allowed order
      }));
    }
  }, [item]);

  const validate = () => {
    const newErrors = {};
    
    if (!formData.label.trim()) {
      newErrors.label = 'Label is required';
    }
    
    if (!formData.path.trim()) {
      newErrors.path = 'Path is required';
    }
    
    if (formData.order !== undefined && formData.order > 7) {
      newErrors.order = 'Order cannot exceed 7';
    }
    
    if (formData.type === 'dropdown' && (!formData.items || formData.items.length === 0)) {
      newErrors.items = 'Dropdown must have at least one item';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    let processedValue = value;
    
    if (name === 'order') {
      const numValue = parseInt(value) || 0;
      // Enforce max limit of 7
      processedValue = numValue > 7 ? 7 : numValue;
    }
    
    setFormData(prev => ({ 
      ...prev, 
      [name]: name === 'order' ? processedValue : value 
    }));
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: null }));
    }
  };

  const handleAddItem = () => {
    setFormData(prev => ({
      ...prev,
      items: [...(prev.items || []), {
        id: `item-${Date.now()}-${Math.random()}`,
        label: '',
        path: '',
        type: 'link',
        icon: '',
        subItems: []
      }]
    }));
  };

  const handleUpdateItem = (index, updates) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.map((it, i) => 
        i === index ? { ...it, ...updates } : it
      )
    }));
  };

  const handleDeleteItem = (index) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.filter((_, i) => i !== index)
    }));
  };

  const handleAddSubItem = (itemIndex) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.map((it, i) => 
        i === itemIndex 
          ? { 
              ...it, 
              subItems: [...(it.subItems || []), { 
                id: `subitem-${Date.now()}-${Math.random()}`, 
                label: '', 
                path: '', 
                icon: '' 
              }] 
            }
          : it
      )
    }));
  };

  const handleUpdateSubItem = (itemIndex, subIndex, updates) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.map((it, i) => 
        i === itemIndex
          ? { 
              ...it, 
              subItems: it.subItems.map((sit, si) => 
                si === subIndex ? { ...sit, ...updates } : sit
              ) 
            }
          : it
      )
    }));
  };

  const handleDeleteSubItem = (itemIndex, subIndex) => {
    setFormData(prev => ({
      ...prev,
      items: prev.items.map((it, i) => 
        i === itemIndex
          ? { 
              ...it, 
              subItems: it.subItems.filter((_, si) => si !== subIndex) 
            }
          : it
      )
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validate()) {
      return;
    }

    try {
      const { addNavigationItem, updateNavigationItem, findNavigationItemByLabel, findNavigationItemByPath, createOrUpdateNavigationItemByLabel } = await import('../../services/navigationService');
      
      // Check if item exists and has a valid ID (firestoreId or id)
      // Use originalItem if available to get the original identifiers
      const itemToCheck = originalItem || item;
      const isEditing = !!itemToCheck; // True if we're editing an existing item
      
      let docId = itemToCheck ? (itemToCheck.firestoreId || itemToCheck.id || formData.firestoreId || formData.id) : null;
      let hasValidId = docId && docId.trim() !== '';
      
      // If we're editing an item but don't have a valid ID, try to find it by the ORIGINAL label
      // This is crucial - we use the ORIGINAL label, not the new one the user typed
      // This prevents creating duplicates when the user changes the label
      if (isEditing && !hasValidId && itemToCheck.label) {
        try {
          // Use the original label from when the item was loaded, not the form data label (which might have been changed)
          // For example, if user is editing "Home" to "Hom", we search for "Home" not "Hom"
          let foundItem = await findNavigationItemByLabel(itemToCheck.label);
          
          // If not found by label, try to find by path (since path is less likely to change)
          // This handles cases where label was changed in a previous edit
          // For example, if "Home" (path: "/") was edited to "Hom", we can still find it by path
          if (!foundItem && itemToCheck.path) {
            foundItem = await findNavigationItemByPath(itemToCheck.path);
          }
          
          if (foundItem) {
            docId = foundItem.firestoreId || foundItem.id;
            hasValidId = docId && docId.trim() !== '';
            // Update formData with the found firestoreId so we can update the correct document
            if (foundItem.firestoreId) {
              setFormData(prev => ({ ...prev, firestoreId: foundItem.firestoreId }));
            }
          } else {
            // Item not found by original label or path - this means it was never saved to Firestore
            // This can happen with generated items. We'll handle this in the else block below
            console.log('Item being edited was not found in Firestore by original label or path:', itemToCheck.label, itemToCheck.path);
          }
        } catch (findError) {
          console.warn('Error finding existing item by original label or path:', findError);
        }
      }
      
      // Only check for duplicates by new label if we're NOT editing (i.e., creating a new item)
      // When editing, we should always update the existing item, not create a new one
      if (!isEditing && !hasValidId && formData.label) {
        try {
          const foundItem = await findNavigationItemByLabel(formData.label);
          if (foundItem) {
            // Found an existing item with this label, update it instead of creating new
            docId = foundItem.firestoreId || foundItem.id;
            hasValidId = docId && docId.trim() !== '';
            if (foundItem.firestoreId) {
              setFormData(prev => ({ ...prev, firestoreId: foundItem.firestoreId }));
            }
          }
        } catch (findError) {
          console.warn('Could not find existing item by new label:', findError);
        }
      }
      
      // If we're editing, we should always update (even if we don't have a valid ID, we'll try to create/update)
      // If we're not editing, we should add a new item
      if (isEditing && hasValidId) {
        // For auto-generated items, preserve id, autoGenerated, and items array, but allow editing other fields
        const updateData = { ...formData };
        if (itemToCheck.autoGenerated) {
          // Preserve auto-generated fields
          updateData.id = itemToCheck.id;
          updateData.autoGenerated = true;
          // Preserve the original auto-generated items array (don't use formData.items which might be stale)
          updateData.items = itemToCheck.items || [];
          // Don't send firestoreId in the update
          if (updateData.firestoreId) {
            delete updateData.firestoreId;
          }
        } else {
          // For non-auto-generated items, remove firestoreId from update data
          if (updateData.firestoreId) {
            delete updateData.firestoreId;
          }
          // Preserve the original id if it exists
          if (itemToCheck.id && !updateData.id) {
            updateData.id = itemToCheck.id;
          }
        }
        
        console.log('Updating navigation item:', { docId, label: updateData.label, path: updateData.path });
        await updateNavigationItem(docId, updateData);
      } else if (isEditing && !hasValidId) {
        // We're editing but couldn't find the item by original label or path
        // Try one more time to find by the NEW path (in case path was also changed)
        // This is a final check to prevent duplicates
        let itemUpdated = false;
        
        if (formData.path) {
          try {
            const foundByNewPath = await findNavigationItemByPath(formData.path);
            if (foundByNewPath) {
              // Found by new path, update it
              docId = foundByNewPath.firestoreId || foundByNewPath.id;
              hasValidId = true;
              const updateData = { ...formData };
              if (updateData.firestoreId) delete updateData.firestoreId;
              // Preserve original id if it exists
              if (itemToCheck.id && !updateData.id) {
                updateData.id = itemToCheck.id;
              }
              await updateNavigationItem(docId, updateData);
              itemUpdated = true;
            }
          } catch (err) {
            console.error('Error finding/updating by new path:', err);
          }
        }
        
        if (!itemUpdated) {
          // Still not found, use createOrUpdateNavigationItemByLabel
          // This will check for duplicates by path and label before creating
          try {
            const updateData = { ...formData };
            if (updateData.firestoreId) delete updateData.firestoreId;
            // Preserve original id if it exists
            if (itemToCheck.id && !updateData.id) {
              updateData.id = itemToCheck.id;
            }
            console.log('Creating/updating navigation item by label:', { 
              originalLabel: itemToCheck.label, 
              newLabel: updateData.label, 
              path: updateData.path 
            });
            await createOrUpdateNavigationItemByLabel(updateData, itemToCheck.label);
          } catch (err) {
            console.error('Error saving edited item:', err);
            throw err;
          }
        }
      } else {
        // Add new item (no item prop means we're creating a new item)
        // But first, do a final check to prevent duplicates
        console.log('Adding new navigation item:', { label: formData.label, path: formData.path });
        await addNavigationItem(formData);
      }
      
      onSave();
    } catch (error) {
      console.error('Error saving navigation item:', error);
      alert('Error saving navigation item. Please try again.');
    }
  };

  return (
    <div className="navigation-editor admin-card">
      <div className="editor-header">
        <h2 className="admin-heading-2">
          {item ? 'Edit Navigation Item' : 'Add New Navigation Item'}
        </h2>
      </div>

      <form onSubmit={handleSubmit} className="editor-form">
        {/* Auto-Generated Info (Read-only) */}
        {item?.autoGenerated && (
          <div className="form-section" style={{ 
            backgroundColor: '#f0f9ff', 
            padding: 'var(--admin-spacing-md)', 
            borderRadius: 'var(--admin-radius-md)',
            marginBottom: 'var(--admin-spacing-md)',
            border: '1px solid #bae6fd'
          }}>
            <h3 className="section-title" style={{ color: '#0369a1', marginBottom: 'var(--admin-spacing-sm)' }}>
              ℹ️ Auto-Generated Item
            </h3>
            <p className="admin-text-sm" style={{ color: '#0c4a6e', marginBottom: 'var(--admin-spacing-sm)' }}>
              This item is automatically generated from brands and categories. The ID and items list are auto-managed. 
              You can edit the label, path, type, and order below.
            </p>
            <div className="form-row">
              <div className="form-group">
                <label className="admin-label">Item ID (Auto-generated)</label>
                <input
                  type="text"
                  value={formData.id || ''}
                  className="admin-input"
                  disabled
                  style={{ backgroundColor: '#e0f2fe', cursor: 'not-allowed' }}
                />
                <small className="form-hint">This ID is automatically generated and cannot be changed</small>
              </div>
            </div>
          </div>
        )}

        {/* Basic Information */}
        <div className="form-section">
          <h3 className="section-title">Basic Information</h3>
          
          <div className="form-group">
            <label className="admin-label">
              Label <span className="required">*</span>
            </label>
            <input
              type="text"
              name="label"
              value={formData.label}
              onChange={handleChange}
              className={`admin-input ${errors.label ? 'input-error' : ''}`}
              placeholder="e.g., Home, About Us, Products"
              required
            />
            {errors.label && <span className="error-message">{errors.label}</span>}
          </div>

          <div className="form-group">
            <label className="admin-label">
              Path <span className="required">*</span>
            </label>
            <input
              type="text"
              name="path"
              value={formData.path}
              onChange={handleChange}
              className={`admin-input ${errors.path ? 'input-error' : ''}`}
              placeholder="e.g., /, /about, /products"
              required
            />
            {errors.path && <span className="error-message">{errors.path}</span>}
            <small className="form-hint">The URL path for this navigation item</small>
          </div>

          <div className="form-row">
            <div className="form-group">
              <label className="admin-label">
                Type <span className="required">*</span>
              </label>
              <select
                name="type"
                value={formData.type}
                onChange={handleChange}
                className="admin-select"
                required
              >
                <option value="link">Simple Link</option>
                <option value="dropdown">Dropdown Menu</option>
              </select>
            </div>

            <div className="form-group">
              <label className="admin-label">
                Order <span className="required">*</span>
              </label>
              <input
                type="number"
                name="order"
                value={formData.order}
                onChange={handleChange}
                className={`admin-input ${errors.order ? 'input-error' : ''}`}
                min="0"
                max="7"
                required
              />
              {errors.order && <span className="error-message">{errors.order}</span>}
              <small className="form-hint">Lower numbers appear first (maximum: 7)</small>
              <div
                className="admin-alert admin-alert-warning"
                style={{
                  padding: "10px 14px",
                  marginTop: "12px",
                  marginBottom: "12px",
                  display: "flex",
                  alignItems: "flex-start",
                  gap: "8px",
                }}
              >
                <span style={{ fontSize: "18px", lineHeight: "1.2" }}>⚠️</span>
                <div style={{ flex: 1 }}>
                  <strong style={{ display: "block", marginBottom: "4px" }}>
                    Display Limit Notice
                  </strong>
                  <span className="admin-text-sm" style={{ display: "block" }}>
                    Only the first <strong>7 navigation items</strong> are displayed in the
                    management list. Use filters or search to find specific items
                    if you have more than 7.
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Dropdown Items */}
        {formData.type === 'dropdown' && (
          <div className="form-section">
            <div className="section-header">
              <h3 className="section-title">Dropdown Items</h3>
              {!item?.autoGenerated && (
                <button
                  type="button"
                  onClick={handleAddItem}
                  className="admin-btn admin-btn-secondary"
                >
                  + Add Item
                </button>
              )}
            </div>
            
            {item?.autoGenerated && (
              <div style={{ 
                backgroundColor: '#fef3c7', 
                padding: 'var(--admin-spacing-sm)', 
                borderRadius: 'var(--admin-radius-sm)',
                marginBottom: 'var(--admin-spacing-md)',
                border: '1px solid #fcd34d'
              }}>
                <p className="admin-text-sm" style={{ color: '#92400e', margin: 0 }}>
                  <strong>⚠️ Auto-Generated:</strong> These dropdown items are automatically generated from brands and categories in Product Management. 
                  They cannot be edited here. To modify them, update the brands/categories in Product Management.
                </p>
              </div>
            )}
            
            {errors.items && (
              <div className="error-message admin-mb-md">{errors.items}</div>
            )}

            {formData.items?.map((dropdownItem, index) => (
              <div key={dropdownItem.id || index} className="dropdown-item-editor" style={{
                ...(item?.autoGenerated ? { 
                  opacity: 0.7,
                  pointerEvents: 'none'
                } : {})
              }}>
                <div className="dropdown-item-header">
                  <h4 className="item-title">Item {index + 1}</h4>
                  {!item?.autoGenerated && (
                    <button
                      type="button"
                      onClick={() => handleDeleteItem(index)}
                      className="admin-btn admin-btn-danger"
                    >
                      Delete
                    </button>
                  )}
                </div>

                <div className="form-row">
                  <div className="form-group">
                    <label className="admin-label">Label</label>
                    <input
                      type="text"
                      placeholder="e.g., Soil King, Wellness"
                      value={dropdownItem.label}
                      onChange={(e) => handleUpdateItem(index, { label: e.target.value })}
                      className="admin-input"
                      disabled={item?.autoGenerated}
                      style={item?.autoGenerated ? { backgroundColor: '#f3f4f6', cursor: 'not-allowed' } : {}}
                    />
                  </div>
                  <div className="form-group">
                    <label className="admin-label">Path</label>
                    <input
                      type="text"
                      placeholder="e.g., /brands/soil-king"
                      value={dropdownItem.path}
                      onChange={(e) => handleUpdateItem(index, { path: e.target.value })}
                      className="admin-input"
                      disabled={item?.autoGenerated}
                      style={item?.autoGenerated ? { backgroundColor: '#f3f4f6', cursor: 'not-allowed' } : {}}
                    />
                  </div>
                </div>

                <div className="form-row">
                  <div className="form-group">
                    <ImageSelector
                      value={dropdownItem.icon || ''}
                      onChange={item?.autoGenerated ? () => {} : (url) => handleUpdateItem(index, { icon: url })}
                      label="Icon (will be converted to circle)"
                      isIcon={true}
                    />
                  </div>
                  <div className="form-group">
                    <label className="admin-label">Item Type</label>
                    <select
                      value={dropdownItem.type || 'link'}
                      onChange={(e) => handleUpdateItem(index, { type: e.target.value })}
                      className="admin-select"
                      disabled={item?.autoGenerated}
                      style={item?.autoGenerated ? { backgroundColor: '#f3f4f6', cursor: 'not-allowed' } : {}}
                    >
                      <option value="link">Simple Link</option>
                      <option value="submenu">Submenu (with sub-items)</option>
                    </select>
                  </div>
                </div>

                {/* Submenu Items */}
                {dropdownItem.type === 'submenu' && (
                  <div className="submenu-section" style={{
                    ...(item?.autoGenerated ? { 
                      opacity: 0.7,
                      pointerEvents: 'none'
                    } : {})
                  }}>
                    <div className="submenu-header">
                      <h5 className="submenu-title">Submenu Items</h5>
                      {!item?.autoGenerated && (
                        <button
                          type="button"
                          onClick={() => handleAddSubItem(index)}
                          className="admin-btn admin-btn-secondary"
                        >
                          + Add Sub-item
                        </button>
                      )}
                    </div>

                    {dropdownItem.subItems?.map((subItem, subIndex) => (
                      <div key={subItem.id || subIndex} className="subitem-editor">
                        <div className="form-row">
                          <div className="form-group">
                            <input
                              type="text"
                              placeholder="Sub-item Label"
                              value={subItem.label}
                              onChange={(e) => handleUpdateSubItem(index, subIndex, { label: e.target.value })}
                              className="admin-input"
                              disabled={item?.autoGenerated}
                              style={item?.autoGenerated ? { backgroundColor: '#f3f4f6', cursor: 'not-allowed' } : {}}
                            />
                          </div>
                          <div className="form-group">
                            <input
                              type="text"
                              placeholder="Sub-item Path"
                              value={subItem.path}
                              onChange={(e) => handleUpdateSubItem(index, subIndex, { path: e.target.value })}
                              className="admin-input"
                              disabled={item?.autoGenerated}
                              style={item?.autoGenerated ? { backgroundColor: '#f3f4f6', cursor: 'not-allowed' } : {}}
                            />
                          </div>
                          <div className="form-group">
                            <ImageSelector
                              value={subItem.icon || ''}
                              onChange={item?.autoGenerated ? () => {} : (url) => handleUpdateSubItem(index, subIndex, { icon: url })}
                              label="Icon (will be converted to circle)"
                              isIcon={true}
                            />
                          </div>
                          {!item?.autoGenerated && (
                            <div className="form-group">
                              <button
                                type="button"
                                onClick={() => handleDeleteSubItem(index, subIndex)}
                                className="admin-btn admin-btn-danger"
                              >
                                Delete
                              </button>
                            </div>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}

        {/* Form Actions */}
        <div className="form-actions">
          <button type="submit" className="admin-btn admin-btn-primary">
            {item ? 'Update Item' : 'Create Item'}
          </button>
          <button 
            type="button" 
            onClick={onCancel} 
            className="admin-btn admin-btn-secondary"
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
}

