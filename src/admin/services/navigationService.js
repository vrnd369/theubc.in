import { 
  collection, 
  doc, 
  getDocs, 
  getDocsFromServer,
  getDocFromServer,
  addDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  orderBy,
  getDoc,
  setDoc
} from 'firebase/firestore';
import { db } from '../../firebase/config';
import { validateAndCompressDocument } from '../../utils/firestoreCompression';
import { getBrands, getCategories } from './productService';
import { isExistingUser, markUserAsExisting } from '../../utils/userCache';
import { MODULES } from '../auth/roleConfig';

const NAVIGATION_COLLECTION = 'navigation';
const NAVIGATION_CONFIG_DOC = 'navigation-config';

// Helper to convert category chip to URL slug
const chipToSlug = (chip) => {
  if (!chip || chip === 'All') return null;
  return chip.toLowerCase().replace(/\s+/g, '-').replace(/&/g, '');
};

/**
 * Generate navigation items dynamically from brands and categories
 * @returns {Promise<Array>} Array of navigation items
 */
export const generateNavigationFromProducts = async () => {
  try {
    // Check module visibility settings
    const { getModuleVisibility } = await import('./moduleVisibilityService');
    const moduleVisibility = await getModuleVisibility();
    const isProductsVisible = moduleVisibility[MODULES.PRODUCTS] !== false;
    const isBrandPagesVisible = moduleVisibility[MODULES.BRAND_PAGES] !== false;

    const [brands, categories] = await Promise.all([
      getBrands(),
      getCategories()
    ]);

    // Filter enabled items only
    const enabledBrands = brands.filter(b => b.enabled !== false);
    const enabledCategories = categories.filter(c => c.enabled !== false);

    // Build navigation structure
    const navigationItems = [
      {
        id: 'nav-home',
        label: 'Home',
        path: '/',
        type: 'link',
        order: 1
      },
      {
        id: 'nav-about',
        label: 'About Us',
        path: '/about',
        type: 'link',
        order: 2
      }
    ];

    // Add "Our Brands" dropdown if there are brands AND brand pages module is visible
    if (enabledBrands.length > 0 && isBrandPagesVisible) {
      const brandItems = enabledBrands.map(brand => ({
        id: `brand-${brand.brandId || brand.id}`,
        label: brand.name,
        path: `/brands/${brand.brandId || brand.id}`,
        type: 'link',
        icon: brand.icon || null
      }));

      navigationItems.push({
        id: 'nav-our-brands', // Unique ID for this dropdown
        label: 'Our Brands',
        path: '/brands',
        type: 'dropdown',
        order: 3,
        items: brandItems,
        autoGenerated: true // Mark as auto-generated
      });
    }

    // Add "Products" dropdown with categories only (no brands) if products module is visible
    if (enabledCategories.length > 0 && isProductsVisible) {
      const productItems = enabledCategories.map(category => {
        const categorySlug = chipToSlug(category.chip) || category.id;
        // Get brand identifier for the category
        // category.brandId stores the Firestore document ID, so we need to find the brand
        // and get its identifier (brand.brandId)
        const brand = enabledBrands.find(b => b.id === category.brandId);
        const brandIdentifier = brand ? (brand.brandId || brand.id) : null;
        return {
          id: `category-${category.id}`,
          label: category.chip || category.title,
          path: `/products?category=${categorySlug}${brandIdentifier ? `&brand=${brandIdentifier}` : ''}`,
          type: 'link',
          icon: category.image || null
        };
      });

      if (productItems.length > 0) {
        navigationItems.push({
          id: 'nav-products', // Unique ID for this dropdown
          label: 'Products',
          path: '/products',
          type: 'dropdown',
          order: 4,
          items: productItems,
          autoGenerated: true // Mark as auto-generated
        });
      }
    }

    // Add static navigation items
    navigationItems.push(
      {
        id: 'nav-contact',
        label: 'Contact Us',
        path: '/contact',
        type: 'link',
        order: 5
      },
      {
        id: 'nav-careers',
        label: 'Careers',
        path: '/careers',
        type: 'link',
        order: 6
      }
    );

    return navigationItems;
  } catch (error) {
    console.error('Error generating navigation from products:', error);
    throw error;
  }
};

/**
 * Get navigation configuration (whether to use auto-generated or manual navigation)
 * Uses cache for existing users, server for new users
 * @returns {Promise<Object>} Navigation configuration
 */
export const getNavigationConfig = async () => {
  try {
    const useCache = isExistingUser();
    const docSnap = useCache 
      ? await getDoc(doc(db, NAVIGATION_COLLECTION, NAVIGATION_CONFIG_DOC))
      : await getDocFromServer(doc(db, NAVIGATION_COLLECTION, NAVIGATION_CONFIG_DOC));
    if (docSnap.exists()) {
      const config = docSnap.data();
      // Mark user as existing after first successful fetch
      if (!useCache) {
        markUserAsExisting();
      }
      // Ensure autoGenerate defaults to true if not explicitly set to false
      return { 
        autoGenerate: config.autoGenerate !== false, 
        enquiryButtonText: config.enquiryButtonText || 'Enquiry Form',
        enquiryButtonColor: config.enquiryButtonColor || '#007bff',
        hoverEffectColor: config.hoverEffectColor || '#F7F7FB',
        ...config 
      };
    }
    return { 
      autoGenerate: true,
      enquiryButtonText: 'Enquiry Form',
      enquiryButtonColor: '#007bff',
      hoverEffectColor: '#F7F7FB'
    };
  } catch (error) {
    console.error('Error fetching navigation config:', error);
    return { 
      autoGenerate: true,
      enquiryButtonText: 'Enquiry Form',
      enquiryButtonColor: '#007bff',
      hoverEffectColor: '#F7F7FB'
    };
  }
};

/**
 * Set navigation configuration
 * @param {Object} config - Configuration object with autoGenerate flag
 * @returns {Promise<void>}
 */
export const setNavigationConfig = async (config) => {
  try {
    const compressedData = await validateAndCompressDocument({
      ...config,
      updatedAt: new Date().toISOString()
    });

    await setDoc(
      doc(db, NAVIGATION_COLLECTION, NAVIGATION_CONFIG_DOC),
      compressedData,
      { merge: true }
    );
  } catch (error) {
    console.error('Error setting navigation config:', error);
    throw error;
  }
};

/**
 * Get all navigation items - uses auto-generated if enabled, otherwise manual navigation
 * When auto-generate is enabled, merges auto-generated data with saved manual edits
 * @returns {Promise<Array>} Array of navigation items
 */
export const getNavigationItems = async () => {
  try {
    const config = await getNavigationConfig();
    
    // If auto-generate is enabled (default is true), generate from brands/categories
    if (config.autoGenerate !== false) {
      const generatedItems = await generateNavigationFromProducts();
      
      // Get saved manual edits from Firestore
      const useCache = isExistingUser();
      const q = query(collection(db, NAVIGATION_COLLECTION), orderBy('order', 'asc'));
      const snapshot = useCache ? await getDocs(q) : await getDocsFromServer(q);
      const savedItems = snapshot.docs
        .map(doc => ({ 
          firestoreId: doc.id, // Preserve Firestore document ID
          ...doc.data(),
          id: doc.data().id || doc.id // Use item's id field or fallback to Firestore ID
        }))
        .filter(item => item.firestoreId !== NAVIGATION_CONFIG_DOC); // Exclude config doc
      
      // Create a map of saved items by their id field (for auto-generated items) or label
      const savedItemsMap = new Map();
      savedItems.forEach(item => {
        // Map by id field (for auto-generated items with fixed IDs)
        if (item.id) {
          savedItemsMap.set(item.id, item);
        }
        // Also map by label as fallback
        if (item.label) {
          savedItemsMap.set(`label:${item.label}`, item);
        }
      });
      
      // Merge generated items with saved edits
      // For auto-generated items: preserve id and autoGenerated, but use saved edits for other fields
      // For non-auto-generated items: use as-is
      const mergedItems = generatedItems.map(genItem => {
        // Find matching saved item by ID or label
        let savedItem = savedItemsMap.get(genItem.id) || savedItemsMap.get(`label:${genItem.label}`);
        
        // If not found by label, try to find by path (for items that were edited and label changed)
        // This handles cases where "Home" was edited to "praneeth" - we can still match by path "/"
        // CRITICAL: When matching by path, we want to replace the generated item with the saved one
        // This ensures edited items replace their generated counterparts
        if (!savedItem && genItem.path) {
          // Normalize paths for comparison (remove trailing slashes, ensure consistent format)
          const normalizePath = (p) => p ? p.trim().replace(/\/+$/, '') || '/' : '';
          const genPath = normalizePath(genItem.path);
          
          // Find any saved item with the same path (regardless of autoGenerated status)
          // This ensures that if "Home" (path: "/") was edited to "praneeth" (path: "/"),
          // we find and use the saved "praneeth" instead of the generated "Home"
          savedItem = savedItems.find(item => {
            if (!item.path) return false;
            const itemPath = normalizePath(item.path);
            return itemPath === genPath && 
                   (!genItem.id || !item.id || item.id === genItem.id);
          });
        }
        
        if (savedItem && genItem.autoGenerated) {
          // Merge: keep auto-generated id, autoGenerated flag, and items array
          // But use saved manual edits for label, path, type, order
          return {
            ...genItem,
            // Preserve auto-generated fields
            id: genItem.id,
            autoGenerated: true,
            items: genItem.items, // Keep auto-generated items array
            // Use saved manual edits for editable fields
            label: savedItem.label || genItem.label,
            path: savedItem.path || genItem.path,
            type: savedItem.type || genItem.type,
            order: savedItem.order !== undefined ? savedItem.order : genItem.order,
            // Preserve Firestore document ID for updates
            firestoreId: savedItem.firestoreId
          };
        } else if (savedItem && !genItem.autoGenerated) {
          // Non-auto-generated item that exists in Firestore
          // CRITICAL: When a saved item matches a generated item by path, 
          // we should use the saved item completely (it has the edited label)
          // This ensures "praneeth" replaces "Home" instead of showing both
          return {
            ...savedItem,
            id: savedItem.id || savedItem.firestoreId,
            firestoreId: savedItem.firestoreId // Preserve Firestore document ID for updates
          };
        } else {
          // New auto-generated item, will be saved to Firestore below
          // Only return generated item if no saved item was found
          return genItem;
        }
      });
      
      // Add any saved items that aren't in the generated list (manual-only items)
      // But check by both ID/label AND path to prevent duplicates when labels were changed
      const generatedIds = new Set(generatedItems.map(item => item.id || item.label));
      const normalizePath = (p) => p ? p.trim().replace(/\/+$/, '') || '/' : '';
      const generatedPaths = new Set(
        generatedItems
          .map(item => item.path ? normalizePath(item.path) : null)
          .filter(path => path !== null)
      );
      
      savedItems.forEach(savedItem => {
        // Check if this saved item is already in the merged list by ID, label, or path
        const savedItemId = savedItem.id || savedItem.label;
        const savedItemPath = savedItem.path ? normalizePath(savedItem.path) : null;
        const isAlreadyInGenerated = generatedIds.has(savedItemId) || 
                                     (savedItemPath && generatedPaths.has(savedItemPath));
        
        // Only add if it's not auto-generated and not already in the generated list
        if (!savedItem.autoGenerated && !isAlreadyInGenerated) {
          mergedItems.push({
            ...savedItem,
            id: savedItem.id || savedItem.firestoreId,
            firestoreId: savedItem.firestoreId // Ensure firestoreId is preserved
          });
        }
      });
      
      // Save/update auto-generated items in Firestore
      for (const item of generatedItems) {
        if (item.autoGenerated && item.id) {
          const savedItem = savedItemsMap.get(item.id) || savedItemsMap.get(`label:${item.label}`);
          const itemToSave = {
            id: item.id,
            autoGenerated: true,
            items: item.items, // Auto-generated items array
            // Preserve manual edits if they exist
            label: savedItem?.label || item.label,
            path: savedItem?.path || item.path,
            type: savedItem?.type || item.type,
            order: savedItem?.order !== undefined ? savedItem.order : item.order,
            updatedAt: new Date().toISOString()
          };
          
          // Use the item's ID as Firestore document ID (for items with fixed IDs like 'nav-our-brands')
          // Or use existing Firestore document ID if found
          const docId = savedItem?.firestoreId || item.id;
          
          const compressedData = await validateAndCompressDocument({
            ...itemToSave,
            ...(savedItem ? {} : { createdAt: new Date().toISOString() })
          });
          await setDoc(doc(db, NAVIGATION_COLLECTION, docId), compressedData, { merge: true });
        }
      }
      
      // Sort by order
      mergedItems.sort((a, b) => (a.order || 0) - (b.order || 0));
      
      // Mark user as existing after first successful fetch
      if (!useCache && mergedItems.length >= 0) {
        markUserAsExisting();
      }
      
      return mergedItems;
    }

    // Otherwise, use manual navigation from Firestore
    const useCache = isExistingUser();
    const q = query(collection(db, NAVIGATION_COLLECTION), orderBy('order', 'asc'));
    const snapshot = useCache ? await getDocs(q) : await getDocsFromServer(q);
    const items = snapshot.docs
      .map(doc => ({ 
        id: doc.id, 
        firestoreId: doc.id, // Preserve Firestore ID
        ...doc.data() 
      }))
      .filter(item => item.id !== NAVIGATION_CONFIG_DOC); // Exclude config doc
    
    // Mark user as existing after first successful fetch
    if (!useCache && items.length >= 0) {
      markUserAsExisting();
    }
    
    return items;
  } catch (error) {
    console.error('Error fetching navigation items:', error);
    // Fallback to auto-generated navigation on error
    try {
      return await generateNavigationFromProducts();
    } catch (fallbackError) {
      console.error('Error in fallback navigation generation:', fallbackError);
      throw error; // Throw original error
    }
  }
};

/**
 * Add a new navigation item
 * @param {Object} item - Navigation item data
 * @returns {Promise<string>} Document ID of the new item
 */
export const addNavigationItem = async (item) => {
  try {
    // Validate order doesn't exceed maximum of 7
    if (item.order !== undefined && item.order > 7) {
      throw new Error('Order cannot exceed 7');
    }
    
    // Check if an item with the same label already exists
    if (item.label) {
      const existingItem = await findNavigationItemByLabel(item.label);
      if (existingItem) {
        // Item already exists, update it instead of creating a new one
        const updateData = { ...item };
        if (updateData.firestoreId) {
          delete updateData.firestoreId;
        }
        await updateNavigationItem(existingItem.firestoreId || existingItem.id, updateData);
        return existingItem.firestoreId || existingItem.id;
      }
    }
    
    // Also check by path to prevent duplicates when label was changed
    if (item.path) {
      const existingByPath = await findNavigationItemByPath(item.path);
      if (existingByPath) {
        // Item with same path exists, update it instead of creating a new one
        const updateData = { ...item };
        if (updateData.firestoreId) {
          delete updateData.firestoreId;
        }
        await updateNavigationItem(existingByPath.firestoreId || existingByPath.id, updateData);
        return existingByPath.firestoreId || existingByPath.id;
      }
    }
    
    const compressedData = await validateAndCompressDocument({
      ...item,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    const docRef = await addDoc(collection(db, NAVIGATION_COLLECTION), compressedData);
    return docRef.id;
  } catch (error) {
    console.error('Error adding navigation item:', error);
    throw error;
  }
};

/**
 * Update an existing navigation item
 * @param {string} id - Document ID (can be Firestore document ID or item's id field)
 * @param {Object} updates - Fields to update
 * @returns {Promise<void>}
 */
export const updateNavigationItem = async (id, updates) => {
  try {
    // Validate inputs
    if (!updates || typeof updates !== 'object') {
      throw new Error('Updates object is required');
    }
    
    if (!id && !updates?.firestoreId) {
      throw new Error('Navigation item ID is required');
    }
    
    // If the item has a firestoreId, use that; otherwise use the id parameter
    const docId = updates?.firestoreId || id;
    
    if (!docId || typeof docId !== 'string') {
      throw new Error(`Invalid document ID: ${docId}`);
    }
    
    // For auto-generated items, preserve the id and autoGenerated fields
    // Don't allow editing of these fields
    const updateData = { ...updates };
    if (updateData.autoGenerated) {
      // Remove firestoreId from update data (it's internal)
      delete updateData.firestoreId;
      // Preserve auto-generated id and autoGenerated flag
      // These should not be changed by user edits
    }
    
    // Remove firestoreId from update data if present (it's internal, not a field to update)
    if (updateData.firestoreId) {
      delete updateData.firestoreId;
    }
    
    // Validate order doesn't exceed maximum of 7
    if (updateData.order !== undefined && updateData.order > 7) {
      throw new Error('Order cannot exceed 7');
    }
    
    // Ensure updateData is not empty
    if (Object.keys(updateData).length === 0) {
      throw new Error('No valid fields to update');
    }
    
    const docRef = doc(db, NAVIGATION_COLLECTION, docId);
    
    // Check if document exists
    const docSnap = await getDoc(docRef);
    const documentExists = docSnap.exists();
    
    const compressedData = await validateAndCompressDocument({
      ...updateData,
      updatedAt: new Date().toISOString(),
      // Only add createdAt if document doesn't exist
      ...(documentExists ? {} : { createdAt: new Date().toISOString() })
    });

    // Use setDoc with merge to handle both create and update cases
    await setDoc(docRef, compressedData, { merge: true });
  } catch (error) {
    console.error('Error updating navigation item:', error);
    throw error;
  }
};

/**
 * Create a normalized document ID from a label
 * @param {string} label - The label to normalize
 * @returns {string} Normalized document ID
 */
const normalizeLabelToDocId = (label) => {
  if (!label) return null;
  // Convert to lowercase, replace spaces with hyphens, remove special chars
  return label.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
};

/**
 * Create or update a navigation item using label-based document ID
 * This ensures items can be found consistently even when labels change
 * @param {Object} item - Navigation item data
 * @param {string} originalLabel - The original label to use for document ID
 * @returns {Promise<string>} Document ID
 */
export const createOrUpdateNavigationItemByLabel = async (item, originalLabel) => {
  try {
    // Validate order doesn't exceed maximum of 7
    if (item.order !== undefined && item.order > 7) {
      throw new Error('Order cannot exceed 7');
    }
    
    if (!originalLabel) {
      // Fallback to regular add if no original label
      return await addNavigationItem(item);
    }
    
    // FIRST: Check if an item with the same path already exists (to prevent duplicates)
    // This handles cases where the item was saved with a different document ID
    if (item.path) {
      const existingByPath = await findNavigationItemByPath(item.path);
      if (existingByPath) {
        // Item with same path exists, update it instead of creating a new one
        const updateData = { ...item };
        if (updateData.firestoreId) {
          delete updateData.firestoreId;
        }
        await updateNavigationItem(existingByPath.firestoreId || existingByPath.id, updateData);
        return existingByPath.firestoreId || existingByPath.id;
      }
    }
    
    // SECOND: Check if an item with the new label already exists
    if (item.label) {
      const existingByLabel = await findNavigationItemByLabel(item.label);
      if (existingByLabel) {
        // Item with same label exists, update it instead of creating a new one
        const updateData = { ...item };
        if (updateData.firestoreId) {
          delete updateData.firestoreId;
        }
        await updateNavigationItem(existingByLabel.firestoreId || existingByLabel.id, updateData);
        return existingByLabel.firestoreId || existingByLabel.id;
      }
    }
    
    // Use normalized original label as document ID for consistency
    const docId = normalizeLabelToDocId(originalLabel);
    if (!docId) {
      // Fallback to regular add if normalization fails
      return await addNavigationItem(item);
    }
    
    const compressedData = await validateAndCompressDocument({
      ...item,
      updatedAt: new Date().toISOString()
    });
    
    // Check if document exists with this ID
    const docRef = doc(db, NAVIGATION_COLLECTION, docId);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      // Update existing document
      await updateDoc(docRef, compressedData);
      return docId;
    } else {
      // Before creating, do one final check: get ALL items and check if any match by path
      // This is a safety net in case the previous checks missed something
      if (item.path) {
        const useCache = isExistingUser();
        const q = query(collection(db, NAVIGATION_COLLECTION));
        const snapshot = useCache ? await getDocs(q) : await getDocsFromServer(q);
        const allItems = snapshot.docs
          .map(doc => ({ 
            firestoreId: doc.id,
            ...doc.data()
          }))
          .filter(docItem => docItem.firestoreId !== NAVIGATION_CONFIG_DOC);
        
        const matchingItem = allItems.find(docItem => docItem.path === item.path);
        if (matchingItem) {
          // Found a matching item by path, update it instead
          const updateData = { ...item };
          if (updateData.firestoreId) {
            delete updateData.firestoreId;
          }
          await updateNavigationItem(matchingItem.firestoreId, updateData);
          return matchingItem.firestoreId;
        }
      }
      
      // No matching item found, create new document with the normalized ID
      await setDoc(docRef, {
        ...compressedData,
        createdAt: new Date().toISOString()
      });
      return docId;
    }
  } catch (error) {
    console.error('Error creating/updating navigation item by label:', error);
    // Fallback to regular add (which also checks for duplicates)
    return await addNavigationItem(item);
  }
};

/**
 * Find a navigation item by label
 * @param {string} label - The label to search for
 * @returns {Promise<Object|null>} The navigation item if found, null otherwise
 */
export const findNavigationItemByLabel = async (label) => {
  try {
    if (!label || typeof label !== 'string') {
      return null;
    }
    
    const useCache = isExistingUser();
    const q = query(collection(db, NAVIGATION_COLLECTION));
    const snapshot = useCache ? await getDocs(q) : await getDocsFromServer(q);
    
    const items = snapshot.docs
      .map(doc => ({ 
        firestoreId: doc.id,
        ...doc.data()
      }))
      .filter(item => item.firestoreId !== NAVIGATION_CONFIG_DOC);
    
    // Find item by exact label match
    const foundItem = items.find(item => item.label === label);
    
    if (foundItem) {
      return {
        ...foundItem,
        id: foundItem.id || foundItem.firestoreId
      };
    }
    
    return null;
  } catch (error) {
    console.error('Error finding navigation item by label:', error);
    return null;
  }
};

/**
 * Find a navigation item by path
 * @param {string} path - The path to search for
 * @returns {Promise<Object|null>} The navigation item if found, null otherwise
 */
export const findNavigationItemByPath = async (path) => {
  try {
    if (!path || typeof path !== 'string') {
      return null;
    }
    
    const useCache = isExistingUser();
    const q = query(collection(db, NAVIGATION_COLLECTION));
    const snapshot = useCache ? await getDocs(q) : await getDocsFromServer(q);
    
    const items = snapshot.docs
      .map(doc => ({ 
        firestoreId: doc.id,
        ...doc.data()
      }))
      .filter(item => item.firestoreId !== NAVIGATION_CONFIG_DOC);
    
    // Find item by exact path match
    const foundItem = items.find(item => item.path === path);
    
    if (foundItem) {
      return {
        ...foundItem,
        id: foundItem.id || foundItem.firestoreId
      };
    }
    
    return null;
  } catch (error) {
    console.error('Error finding navigation item by path:', error);
    return null;
  }
};

/**
 * Delete a navigation item
 * @param {string} id - Document ID (can be Firestore document ID or item's id field)
 * @returns {Promise<void>}
 */
export const deleteNavigationItem = async (id) => {
  try {
    // Validate that id is provided and is a string
    if (!id || typeof id !== 'string') {
      throw new Error(`Invalid navigation item ID: ${id}. ID must be a non-empty string.`);
    }
    
    // Ensure the ID is not empty after trimming
    const trimmedId = id.trim();
    if (!trimmedId) {
      throw new Error('Navigation item ID cannot be empty.');
    }
    
    await deleteDoc(doc(db, NAVIGATION_COLLECTION, trimmedId));
  } catch (error) {
    console.error('Error deleting navigation item:', error);
    throw error;
  }
};

/**
 * Sync navigation when brands/categories change
 * This is called automatically when products are updated
 * @returns {Promise<void>}
 */
export const syncNavigationFromProducts = async () => {
  try {
    const config = await getNavigationConfig();
    // Only sync if auto-generate is enabled
    if (config.autoGenerate !== false) {
      // Navigation will be auto-generated on next getNavigationItems call
      // This function exists for explicit sync if needed
    }
  } catch (error) {
    console.error('Error syncing navigation:', error);
    throw error;
  }
};

/**
 * Ensure auto-generation is enabled (force enable if disabled)
 * @returns {Promise<void>}
 */
export const ensureAutoGenerateEnabled = async () => {
  try {
    const config = await getNavigationConfig();
    if (config.autoGenerate === false) {
      await setNavigationConfig({ autoGenerate: true });
    }
  } catch (error) {
    console.error('Error ensuring auto-generation is enabled:', error);
    throw error;
  }
};

